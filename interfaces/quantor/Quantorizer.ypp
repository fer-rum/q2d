%header{
#include <vector>
#include <cctype>
#include <cassert>

#include <string.h>

#include "Quantor.h"
#include "QICircuit.h"
#include "QIContext.h"
#include "ParseException.h"

using namespace q2d::quantor;
}

/**
 * Quantorizer specification for the wisent parser generator.
 * The generated Quantorizer class transforms a function circuit
 * specification into a QBF problem and uses the QBF solver Quantor
 * to determine an implementing circuit configuration if it exists.
 * The only public utility method is the static Quantorizer::solve
 * function.
 *
 * @author Thomas B. Preu√üer <thomas.preusser@utexas.edu>
 */
%class q2d::quantor::Quantorizer {
  Quantor   quantor;
  unsigned  max_var;
#ifndef NDEBUG
  unsigned  max_named;
#endif

  std::vector<int>  clauses;
  QIContext const  *context;
  char      const  *formula;

//- Life Cycle ---------------------------------------------------------------
private:
  Quantorizer();
  ~Quantorizer();

//- Problem Building ---------------------------------------------------------
private:
  template<typename IT>
  void openScope(QuantorQuantificationType const  type, IT  vars);
  void closeScope();

//- Private Parser Helpers ---------------------------------------------------
private:
  unsigned makeAuxiliary();
  void addClause(int const  a);
  void addClause(int const  a, int const  b);
  void addClause(int const  a, int const  b, int const  c);

//- Parser Interface Methods -------------------------------------------------
private:
  void error(std::string  msg);
  unsigned nextToken(YYSVal &sval);

//- Usage Interface ----------------------------------------------------------
private:
  Result solve0(QICircuit const &c, std::vector<int> &sol);
public:
  static Result solve(QICircuit const &c, std::vector<int> &sol);
}

%sval unsigned
%impl {
#include "Quantorizer.hpp"

using namespace q2d::quantor;

//- Life Cycle ---------------------------------------------------------------
inline Quantorizer::Quantorizer() : max_var(0), context(0), formula(0) {}
inline Quantorizer::~Quantorizer() {}

//- Problem Building ---------------------------------------------------------
template<typename IT>
void Quantorizer::openScope(QuantorQuantificationType const  type, IT  vars) {
  quantor.scope(type);
  for(unsigned const  var : vars) {
    assert(var > 0);
    if(var > max_var)  max_var = var;
    quantor.add(var);
  }
}
inline void Quantorizer::closeScope() { quantor.add(0); }

//- Private Parser Helpers ---------------------------------------------------
inline unsigned Quantorizer::makeAuxiliary() {
  unsigned const  res = ++max_var;
  quantor.add(res);
  return  res;
}
inline void Quantorizer::addClause(int const  a) {
  clauses.push_back(a);
  clauses.push_back(0);
}
inline void Quantorizer::addClause(int const  a, int const  b) {
  clauses.push_back(a);
  clauses.push_back(b);
  clauses.push_back(0);
}
inline void Quantorizer::addClause(int const  a, int const  b, int const  c) {
  clauses.push_back(a);
  clauses.push_back(b);
  clauses.push_back(c);
  clauses.push_back(0);
}

//- Parser Interface Methods -------------------------------------------------
inline void Quantorizer::error(std::string  msg) {
  throw  ParseException(msg, *context);
}

unsigned Quantorizer::nextToken(YYSVal &sval) {
  assert(formula != 0);
  while(true) {
    char const  c = *formula++;
    switch(c) {
    case '\0':
      formula = 0;
    case '(':
    case ')':
    case '=':
      return  c;
    case '!':
    case '~':
      return  NOT;
    case '&':
      if(*formula == '&')  formula++;
    case '*':
      return  AND;
    case '|':
      if(*formula == '|')  formula++;
    case '+':
      return  OR;
    case '^':
      return  XOR;
    }
    if(isspace(c))  continue;
    if(isalpha(c) || (c == '_')) {
      char const *p = formula--;
      while(isalnum(*p) || (*p == '_') || (*p == '/') || (*p == '-'))  p++;
      unsigned const  len = p-formula;
      unsigned  res = 0;
      switch(len) {
      case 2:
    if(strncmp(formula, "or", 2) == 0)  res = OR;
    break;
      case 3:
    if     (strncmp(formula, "and", 3) == 0)  res = AND;
    else if(strncmp(formula, "xor", 3) == 0)  res = XOR;
    else if(strncmp(formula, "nor", 3) == 0)  res = NOR;
    else if(strncmp(formula, "not", 3) == 0)  res = NOT;
    break;
      case 4:
    if     (strncmp(formula, "nand", 4) == 0)  res = NAND;
    else if(strncmp(formula, "xnor", 4) == 0)  res = XNOR;
    break;
      }
      if(res == 0) {
    unsigned const  var = (*context)[std::string(formula, len)];
    assert(var > 0);
    assert(var <= max_named);
    sval = var;
    res  = IDENT;
      }
      formula = p;
      return  res;
    } // isalpha(c)
    error(std::string("Illegal Character: '") + c + "'");
    assert(false);
    return  0;
  }
}

//- Public Usage Interface ---------------------------------------------------
inline Result Quantorizer::solve0(QICircuit const &c, std::vector<int> &sol) {
  // Quantifier Preamble
  openScope(QUANTOR_EXISTENTIAL_VARIABLE_TYPE, c.configVars());
  closeScope();
  openScope(QUANTOR_UNIVERSAL_VARIABLE_TYPE,   c.inputVars());
  closeScope();
  openScope(QUANTOR_EXISTENTIAL_VARIABLE_TYPE, c.nodeVars());
  // leave it open!
#ifndef NDEBUG
  max_named = max_var;
#endif

  // Parse in Component Specifications
  for(QIContext const &ctx : c.contexts()) {
    context = &ctx;
    for(std::string const&  f : ctx.functions()) {
      formula = f.c_str();
      parse();
    }
  }

  // Finish Problem Specification
  closeScope();
  for(int  lit : clauses)  quantor.add(lit);

  // Solve Problem
  Result const  res = quantor.sat();
  if(res == QUANTOR_RESULT_SATISFIABLE) {
    int const *s = quantor.assignment();
    while(*s)  sol.push_back(*s++);
  }
  return  res;
}

Result Quantorizer::solve(QICircuit const &c, std::vector<int> &sol) {
  return  Quantorizer().solve0(c, sol);
}

} // impl

%%
%right NOT
%left AND OR XOR NAND NOR XNOR
%token IDENT
%start spec
%%
spec    : expr {
	   addClause($1);
          }
        | expr '=' expr {
           addClause( $1, -$3);
           addClause(-$1,  $3);
          }
expr    : expr AND  expr {
        unsigned const  res = makeAuxiliary();
        addClause( res, -$1, -$3);
        addClause(-res,  $1);
        addClause(-res,  $3);
        $$ = res;
          }
        | expr OR   expr {
        unsigned const  res = makeAuxiliary();
        addClause(-res,  $1, $3);
        addClause( res, -$1);
        addClause( res, -$3);
        $$ = res;
          }
        | expr XOR  expr {
        unsigned const  res = makeAuxiliary();
        addClause(-res, -$1, -$3);
        addClause(-res,  $1,  $3);
        addClause( res, -$1,  $3);
        addClause( res,  $1, -$3);
        $$ = res;
          }
        | expr NAND expr {
        unsigned const  res = makeAuxiliary();
        addClause(-res, -$1, -$3);
        addClause( res,  $1);
        addClause( res,  $3);
        $$ = res;
          }
        | expr NOR  expr {
        unsigned const  res = makeAuxiliary();
        addClause( res,  $1, $3);
        addClause(-res, -$1);
        addClause(-res, -$3);
        $$ = res;
          }
        | expr XNOR expr {
        unsigned const  res = makeAuxiliary();
        addClause( res, -$1, -$3);
        addClause( res,  $1,  $3);
        addClause(-res, -$1,  $3);
        addClause(-res,  $1, -$3);
        $$ = res;
          }
        | prim           { $$ = $1; }
prim    : IDENT          { $$ = $1; }
    | '(' expr ')'   { $$ = $2; }
    | NOT prim {
        unsigned const  res = makeAuxiliary();
        addClause( res,  $2);
        addClause(-res, -$2);
        $$ = res;
      }
